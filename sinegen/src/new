// use std::collections::HashMap;
use std::net::{UdpSocket, SocketAddrV4, Ipv4Addr};
use std::env;

use core::f32::consts::PI;

#[derive(Debug, Serialize, Deserialize)]
struct Frame {
    data: Vec<f64>,
    port: u16,
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(short, long, required = true)]
    port: u16,
    // #[arg(short, long, required = false)]
    // bind_addr: String,
    #[arg(short, long, required = false)]
    multicast_addr: Ipv4Addr
}


fn main() -> std::io::Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.len() < 3 {
        eprintln!("Usage: {} <multicast_address> <port>", args);
        std::process::exit(1);
    }
    let multicast_addr = args[1].parse::<Ipv4Addr>().unwrap();
    let port = args[2].parse::<u16>().unwrap();
    let socket = UdpSocket::bind("0.0.0.0:0")?;
    socket.set_broadcast(true)?;
    socket.set_multicast_loop_v4(true)?;
    socket.join_multicast_v4(&multicast_addr, &Ipv4Addr::UNSPECIFIED)?;
    // auto by config
    let channels = 16;
    // let mut config = HashMap::new();
    // config.insert(, 16142);
    loop {
        let frame = Frame {
            data: (0..channels).map(|i| (i as f64) * 3.14159 / 8.0).map(|x| x.sin()).collect(),
            port: port,
        };
        let buf = bincode::serialize(&frame).unwrap();
        let multicast_addr = SocketAddrV4::new(multicast_addr, port);
        socket.send_to(&buf, multicast_addr)?;
        Ok(());
    }
    Ok(())
}